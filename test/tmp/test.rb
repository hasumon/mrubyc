#
# Generated by gem 'mrubyc_test' version: 0.2.0
#
# Genarated at: 2019-03-29 18:10:41 +0900
# Your RUBY_DESCRIPTION: ruby 2.6.1p33 (2019-01-30 revision 66950) [x86_64-linux]
#
# For more information, see
#

if RUBY_VERSION == "1.9" && MRUBYC_VERSION
  class Math
  end

  class Numeric
  end

  RUBY_DESCRIPTION = "mruby/c " + MRUBYC_VERSION
else
  require "objspace"

  def debugprint(message)
    puts
    puts "==============================================================================="
    puts message
    puts "Object Space Memory used:#{ObjectSpace.memsize_of_all}"
    puts "==============================================================================="
    puts
  end
end
debugprint(RUBY_DESCRIPTION)
$success_count = 0
$failure_count = 0
$colors = {
  reset: "\e[0m",
  success: "\e[32m",
  failure: "\e[31m",
}

def summerize
  puts "Finished"
  print ($failure_count > 0) ? $colors[:failure] : $colors[:success]
  print ($success_count + $failure_count).to_s + " examples, "
  print $failure_count.to_s + " failures"
  print $colors[:reset]
  puts
  ($failure_count > 0) ? 1 : 0
end

class Object
  def to_ss
    if self.class == NilClass
      "nil [NilClass]"
    elsif self == ""
      "[NULL String]"
    else
      self.to_s + " [" + self.class_name + "]"
    end
  end

  def class_name
    case self.class
    when String
      "String"
    when Array
      "Array"
    when FalseClass
      "FalseClass"
    when Fixnum
      "Fixnum"
    when Float
      "Float"
    when Hash
      "Hash"
    when Math
      "Math"
    when Mutex
      "Mutex"
    when Numeric
      "Numeric"
    when Object
      case self
      when false
        "FalseClass"
      when true
        "TrueClass"
      else
        "Object"
      end
    when Proc
      "Proc"
    when Range
      "Range"
    when String
      "String"
    when Symbol
      "Symbol"
    when VM
      "VM"
    else
      "[User Defined Class]"
    end
  end
end

class Hash
  def add_by_key(key)
    if self.has_key?(key)
      self[key] = +1
    else
      self[key] = 1
    end
  end
end

class Mock
  attr_accessor :expected, :actual

  def initialize
    @expected = {}
    @actual = {}
  end
end

class MrubycTestCase
  def initialize(information)
    @information = information
    $mock ||= Mock.new
    @puts_success_message = true
    @puts_failure_message = true
  end

  def puts_information
    puts
    puts @information[:test_class_name] + "#" + @information[:method_name]
  end

  def success(assertion, expected, actual)
    puts_information
    $success_count += 1
    if @puts_success_message
      puts $colors[:success] + "  assertion : " + assertion.to_s + $colors[:reset]
      puts $colors[:success] + "  result    : " + actual.to_ss + $colors[:reset]
    else
      print $colors[:success] + "." + $colors[:reset]
    end
  end

  def failure(assertion, expected, actual, message)
    puts_information
    $failure_count += 1
    if @puts_failure_message
      puts $colors[:failure] + "  path       : " + @information[:path].to_s
      puts $colors[:failure] + "  line       : " + @information[:line].to_s
      puts $colors[:failure] + "  description: " + @information[:description].to_s
      puts $colors[:failure] + "  " + message if message
      puts $colors[:failure] + "  assertion  : " + assertion.to_s + $colors[:reset]
      puts $colors[:failure] + "  expected   : " + expected.to_ss + $colors[:reset]
      puts $colors[:failure] + "  actual     : " + actual.to_ss + $colors[:reset]
    else
      print $colors[:failure] + "." + $colors[:reset]
    end
  end

  def assert_equal(expected, actual, message = nil)
    assertion = :assert_equal
    actual == expected ? success(assertion, expected, actual) : failure(assertion, expected, actual, message)
  end

  def assert_not_equal(expected, actual, message = nil)
    assertion = :assert_not_equal
    actual != expected ? success(assertion, expected, actual) : failure(assertion, expected, actual, message)
  end

  def assert_not_nil(expression, message = nil)
    assertion = :assert_not_nil
    expression != nil ? success(assertion, nil, expression) : failure(assertion, nil, expression, message)
  end

  def assert(expression, message = nil)
    assertion = :assert
    expression ? success(assertion, nil, expression) : failure(assertion, nil, expression, message)
  end

  def assert_true(expression, message = nil)
    assertion = :assert_true
    expression === true ? success(assertion, nil, expression) : failure(assertion, nil, expression, message)
  end

  def assert_false(expression, message = nil)
    assertion = :assert_false
    expression === false ? success(assertion, nil, expression) : failure(assertion, nil, expression, message)
  end

  def assert_in_delta(expected, actual, message = nil, delta = 0.001)
    assertion = :assert_in_delta
    dt = actual - expected
    if -delta <= dt && dt <= delta
      success(assertion, expected, actual)
    else
      failure(assertion, expected, actual, message)
    end
  end

  def self.description(text)
  end
  def self.desc(text)
  end

  def setup
  end

  def teardown
  end

  def stub(object)
    object
  end

  def check_mock
    $mock.expected.keys.each do |key|
      $mock.actual[key] = 0 unless $mock.actual[key]
      if $mock.expected[key] > $mock.actual[key]
        failure(:mock, $mock.expected[key], $mock.actual[key], key.to_s + " shoud have been called at least expected times")
      else
        success(:mock, $mock.expected[key], $mock.actual[key])
      end
    end
  end
end

class StringStripTest < MrubycTestCase
  description "String#strip"

  def all

    #
    # strip, lstrip, rstrip
    #
    s = " a b c "
    assert_equal "a b c", s.strip
    assert_equal "a b c ", s.lstrip
    assert_equal " a b c", s.rstrip

    s = "abc"
    assert_equal "abc", s.strip
    assert_equal "abc", s.lstrip
    assert_equal "abc", s.rstrip

    s = " abc"
    assert_equal "abc", s.strip
    assert_equal "abc", s.lstrip
    assert_equal " abc", s.rstrip

    s = "abc "
    assert_equal "abc", s.strip
    assert_equal "abc ", s.lstrip
    assert_equal "abc", s.rstrip

    s = " "
    assert_equal "", s.strip
    assert_equal "", s.lstrip
    assert_equal "", s.rstrip

    s = ""
    assert_equal "", s.strip
    assert_equal "", s.lstrip
    assert_equal "", s.rstrip

    s = " \t\r\n\f\vABC \t\r\n\f\v\0"
    assert_equal "ABC", s.strip
    assert_equal "ABC \t\r\n\f\v\0", s.lstrip
    assert_equal " \t\r\n\f\vABC", s.rstrip

    s = " \0ABC\0 "
    assert_equal "\0ABC", s.strip
    assert_equal "\0ABC\0 ", s.lstrip
    assert_equal " \0ABC", s.rstrip

    s = "\0"
    assert_equal "", s.strip
    assert_equal "\0", s.lstrip
    assert_equal "", s.rstrip

    #
    # strip!
    #
    s = " a b c "
    assert_equal "a b c", s.strip!
    assert_equal "a b c", s

    s = "abc"
    assert_equal nil, s.strip!
    assert_equal "abc", s

    s = " abc"
    assert_equal "abc", s.strip!
    assert_equal "abc", s

    s = "abc "
    assert_equal "abc", s.strip!
    assert_equal "abc", s

    s = " "
    assert_equal "", s.strip!
    assert_equal "", s

    s = ""
    assert_equal nil, s.strip!
    assert_equal "", s

    s = " \t\r\n\f\vABC \t\r\n\f\v\0"
    assert_equal "ABC", s.strip!
    assert_equal "ABC", s

    s = " \0ABC\0 "
    assert_equal "\0ABC", s.strip!
    assert_equal "\0ABC", s

    s = "\0"
    assert_equal "", s.strip!
    assert_equal "", s

    #
    # lstrip!
    #
    s = " a b c "
    assert_equal "a b c ", s.lstrip!
    assert_equal "a b c ", s

    s = "abc"
    assert_equal nil, s.lstrip!
    assert_equal "abc", s

    s = " abc"
    assert_equal "abc", s.lstrip!
    assert_equal "abc", s

    s = "abc "
    assert_equal nil, s.lstrip!
    assert_equal "abc ", s

    s = " "
    assert_equal "", s.lstrip!
    assert_equal "", s

    s = ""
    assert_equal nil, s.lstrip!
    assert_equal "", s

    s = " \t\r\n\f\vABC \t\r\n\f\v\0"
    assert_equal "ABC \t\r\n\f\v\0", s.lstrip!
    assert_equal "ABC \t\r\n\f\v\0", s

    s = " \0ABC\0 "
    assert_equal "\0ABC\0 ", s.lstrip!
    assert_equal "\0ABC\0 ", s

    s = "\0"
    assert_equal nil, s.lstrip!
    assert_equal "\0", s

    #
    # rstrip!
    #
    s = " a b c "
    assert_equal " a b c", s.rstrip!
    assert_equal " a b c", s

    s = "abc"
    assert_equal nil, s.rstrip!
    assert_equal "abc", s

    s = " abc"
    assert_equal nil, s.rstrip!
    assert_equal " abc", s

    s = "abc "
    assert_equal "abc", s.rstrip!
    assert_equal "abc", s

    s = " "
    assert_equal "", s.rstrip!
    assert_equal "", s

    s = ""
    assert_equal nil, s.rstrip!
    assert_equal "", s

    s = " \t\r\n\f\vABC \t\r\n\f\v\0"
    assert_equal " \t\r\n\f\vABC", s.rstrip!
    assert_equal " \t\r\n\f\vABC", s

    s = " \0ABC\0 "
    assert_equal " \0ABC", s.rstrip!
    assert_equal " \0ABC", s

    s = "\0"
    assert_equal "", s.rstrip!
    assert_equal "", s

    #
    # chomp
    #
    s1 = "foo\r\n"
    s2 = s1.chomp
    assert_equal "foo\r\n", s1
    assert_equal "foo", s2

    s1 = "foo\r"
    s2 = s1.chomp
    assert_equal "foo\r", s1
    assert_equal "foo", s2

    s1 = "foo\n"
    s2 = s1.chomp
    assert_equal "foo\n", s1
    assert_equal "foo", s2

    s1 = "foo"
    s2 = s1.chomp
    assert_equal "foo", s1
    assert_equal "foo", s2

    s1 = ""
    s2 = s1.chomp
    assert_equal "", s1
    assert_equal "", s2

    s1 = "\r\n"
    s2 = s1.chomp
    assert_equal "\r\n", s1
    assert_equal "", s2

    s1 = "foo\r\n\r\n"
    s2 = s1.chomp
    assert_equal "foo\r\n\r\n", s1
    assert_equal "foo\r\n", s2

    #
    # chomp!
    #
    s = "foo\r\n"
    assert_equal "foo", s.strip!
    assert_equal "foo", s

    s = "foo"
    assert_equal nil, s.strip!
    assert_equal "foo", s

    s = ""
    assert_equal nil, s.strip!
    assert_equal "", s

    s = "\r\n"
    assert_equal "", s.strip!
    assert_equal "", s
  end
end

# frozen_string_literal: true

class FixnumTest < MrubycTestCase
  description "Fixnum"

  def all

    #
    # test Fixnum methods
    #

    # abs
    assert_equal 12, 12.abs
    assert_equal 34.56, (-34.56).abs
    assert_equal 34.56, -34.56.abs

    # chr
    assert_equal "A", 65.chr

    # times
    i = 0
    10.times {
      i += 1
    }
    assert_equal 10, i

    # to_f
    assert_equal(10.0, 10.to_f)
    assert_equal(-10.0, -10.to_f)

    # to_i
    assert_equal(10, 10.to_i)
    assert_equal(-10, -10.to_i)

    # to_s
    assert_equal("10", 10.to_s)
    assert_equal("1010", 10.to_s(2))
    assert_equal("12", 10.to_s(8))
    assert_equal("a", 10.to_s(16))
    assert_equal("z", 35.to_s(36))

    assert_equal("-1", -1.to_s)
    assert_equal("-10", -10.to_s)
    assert_equal("-15wx", -54321.to_s(36))
  end
end

class StringTest < MrubycTestCase
  description "String class"

  def all

    # coding: utf-8
    # string test

    # ==, !=
    assert_equal true, "abc" == "abc"
    assert_equal false, "abc" == "ABC"
    assert_equal false, "abc" == "abcd"
    assert_equal false, "abc" != "abc"
    assert_equal true, "abc" != "ABC"

    # self * times -> String
    s1 = "ABCDEFG"
    s2 = "0123456789"
    assert_equal "ABCDEFGABCDEFG", s1 * 2
    assert_equal "abcabc", "abc" * 2

    # self + other -> String
    assert_equal "ABCDEFG0123456789", s1 + s2
    assert_equal "ABCDEFG123", s1 + "123"
    assert_equal "abc0123456789", "abc" + s2
    assert_equal "abc123", "abc" + "123"

    # self << other -> self
    s1 = "ABCDEFG"
    s1 << s2
    assert_equal "ABCDEFG0123456789", s1
    s1 << "abc"
    assert_equal "ABCDEFG0123456789abc", s1
    assert_equal "abcdef", "abc" << "def"
    s1 << 65
    assert_equal "ABCDEFG0123456789abcA", s1

    # self <=> other -> (minus) | 0 | (plus) | nil
    assert ("aaa" <=> "xxx") < 0
    assert ("aaa" <=> "aaa") == 0
    assert ("xxx" <=> "aaa") > 0
    assert ("string" <=> "stringAA") < 0
    assert ("string" <=> "string") == 0
    assert ("stringAA" <=> "string") > 0

    # self == other -> bool
    s1 = "ABCDEFG"
    assert_equal "ABCDEFG", s1

    # self[nth] -> String | nil
    assert_equal "r", "bar"[2]
    assert_equal true, "bar"[2] == ?r
    assert_equal "r", "bar"[-1]
    assert_equal nil, "bar"[3]
    assert_equal nil, "bar"[-4]

    # self[nth, len] -> String | nil
    str0 = "bar"
    assert_equal "r", str0[2, 1]
    assert_equal "", str0[2, 0]
    assert_equal "r", str0[2, 100]  # (右側を超えても平気
    assert_equal "r", str0[-1, 1]
    assert_equal "r", str0[-1, 2]   # (あくまでも「右に向かって len 文字」

    assert_equal "", str0[3, 1]
    assert_equal nil, str0[4, 1]
    assert_equal nil, str0[-4, 1]
    str1 = str0[0, 2]               # (str0 の「一部」を str1 とする
    assert_equal "ba", str1
    str1[0] = "XYZ"
    assert_equal "XYZa", str1     #(str1 の内容が破壊的に変更された
    assert_equal "bar", str0      #(str0 は無傷、 str1 は str0 と内容を共有していない

    # 境界値チェックを詳細にかけておく
    s1 = "0123456"

    assert_equal "012", s1[0, 3]
    assert_equal "123", s1[1, 3]
    assert_equal "", s1[1, 0]
    assert_equal "123456", s1[1, 30]

    assert_equal nil, s1[3, -1]
    assert_equal nil, s1[3, -3]
    assert_equal nil, s1[3, -4]
    assert_equal nil, s1[3, -5]

    assert_equal "6", s1[6, 1]
    assert_equal "", s1[6, 0]
    assert_equal "", s1[7, 1]     # ??
    assert_equal "", s1[7, 0]     # ??
    assert_equal nil, s1[7, -1]
    assert_equal nil, s1[7, -2]
    assert_equal nil, s1[8, 1]
    assert_equal nil, s1[8, 0]
    assert_equal nil, s1[8, -1]
    assert_equal nil, s1[8, -2]

    assert_equal "", s1[-3, 0]
    assert_equal "45", s1[-3, 2]
    assert_equal "456", s1[-3, 3]
    assert_equal "456", s1[-3, 4]

    assert_equal "", s1[-1, 0]
    assert_equal "6", s1[-1, 1]
    assert_equal "6", s1[-1, 2]
    assert_equal "12", s1[-6, 2]
    assert_equal "01", s1[-7, 2]
    assert_equal nil, s1[-8, 0]
    assert_equal nil, s1[-8, 1]

    assert_equal nil, s1[-3, -1]

    #
    # self[nth] = val
    #
    s1 = "0123456789"
    s1[0] = "ab"
    assert_equal "ab123456789", s1

    s1 = "0123456789"
    s1[1] = "ab"
    assert_equal "0ab23456789", s1

    s1 = "0123456789"
    s1[9] = "ab"
    assert_equal "012345678ab", s1

    s1 = "0123456789"
    s1[10] = "ab"
    assert_equal "0123456789ab", s1

    s1 = "0123456789"
    s1[-1] = "ab"
    assert_equal "012345678ab", s1

    s1 = "0123456789"
    s1[-2] = "ab"
    assert_equal "01234567ab9", s1

    s1 = "0123456789"
    s1[-10] = "ab"
    assert_equal "ab123456789", s1

    s1 = "0123456789"
    s1[0] = ""
    assert_equal "123456789", s1

    s1 = "0123456789"
    s1[1] = ""
    assert_equal "023456789", s1

    s1 = "0123456789"
    s1[9] = ""
    assert_equal "012345678", s1

    s1 = "0123456789"
    s1[10] = ""
    assert_equal "0123456789", s1

    s1 = "0123456789"
    s1[-1] = ""
    assert_equal "012345678", s1

    s1 = "0123456789"
    s1[-2] = ""
    assert_equal "012345679", s1

    s1 = "0123456789"
    s1[-10] = ""
    assert_equal "123456789", s1

    #
    # self[nth, len] = val
    #
    s1 = "0123456789"
    s1[2, 5] = "ab"
    assert_equal "01ab789", s1

    s1 = "0123456789"
    s1[2, 8] = "ab"
    assert_equal "01ab", s1

    s1 = "0123456789"
    s1[2, 9] = "ab"
    assert_equal "01ab", s1

    s1 = "0123456789"
    s1[2, 1] = "ab"
    assert_equal "01ab3456789", s1

    s1 = "0123456789"
    s1[2, 0] = "ab"
    assert_equal "01ab23456789", s1

    s1 = "0123456789"
    s1[0, 5] = "ab"
    assert_equal "ab56789", s1

    s1 = "0123456789"
    s1[0, 10] = "ab"
    assert_equal "ab", s1

    s1 = "0123456789"
    s1[0, 99] = "ab"
    assert_equal "ab", s1

    s1 = "0123456789"
    s1[9, 1] = "ab"
    assert_equal "012345678ab", s1

    s1 = "0123456789"
    s1[10, 1] = "ab"
    assert_equal "0123456789ab", s1

    s1 = "0123456789"
    s1[10, 0] = "ab"
    assert_equal "0123456789ab", s1

    s1 = "0123456789"
    s1[2, 5] = ""
    assert_equal "01789", s1

    s1 = "0123456789"
    s1[2, 8] = ""
    assert_equal "01", s1

    s1 = "0123456789"
    s1[2, 9] = ""
    assert_equal "01", s1

    s1 = "0123456789"
    s1[2, 1] = ""
    assert_equal "013456789", s1

    s1 = "0123456789"
    s1[2, 0] = ""
    assert_equal "0123456789", s1

    s1 = "0123456789"
    s1[0, 5] = ""
    assert_equal "56789", s1

    s1 = "0123456789"
    s1[0, 10] = ""
    assert_equal "", s1

    s1 = "0123456789"
    s1[0, 99] = ""
    assert_equal "", s1

    s1 = "0123456789"
    s1[9, 1] = ""
    assert_equal "012345678", s1

    s1 = "0123456789"
    s1[10, 1] = ""
    assert_equal "0123456789", s1

    s1 = "0123456789"
    s1[10, 0] = ""
    assert_equal "0123456789", s1

    # minus
    s1 = "0123456789"
    s1[-8, 5] = "ab"
    assert_equal "01ab789", s1

    s1 = "0123456789"
    s1[-8, 8] = "ab"
    assert_equal "01ab", s1

    s1 = "0123456789"
    s1[-8, 9] = "ab"
    assert_equal "01ab", s1

    s1 = "0123456789"
    s1[-8, 1] = "ab"
    assert_equal "01ab3456789", s1

    s1 = "0123456789"
    s1[-8, 0] = "ab"
    assert_equal "01ab23456789", s1

    s1 = "0123456789"
    s1[-1, 1] = "ab"
    assert_equal "012345678ab", s1

    s1 = "0123456789"
    s1[-1, 0] = "ab"
    assert_equal "012345678ab9", s1

    # ord
    assert_equal 97, "a".ord
    assert_equal 97, "abcde".ord

    # binary string
    s1 = "ABC\x00\x0d\x0e\x0f"
    assert_equal 7, s1.size

    i = 0
    while i < 3
      s1[i] = i.chr
      i += 1
    end
    assert_equal "\x00\x01\x02\x00\x0d\x0e\x0f", s1
    while i < 10
      s1[i] = i.chr
      i += 1
    end
    assert_equal 10, s1.size
    assert_equal "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09", s1

    # index
    assert_equal 0, "abcde".index("")
    assert_equal 0, "abcde".index("a")
    assert_equal 0, "abcde".index("abc")
    assert_equal 1, "abcde".index("bcd")
    assert_equal 3, "abcde".index("de")
    assert_equal nil, "abcde".index("def")

    assert_equal 2, "abcde".index("c", 1)
    assert_equal 2, "abcde".index("c", 2)
    assert_equal nil, "abcde".index("c", 3)

    #
    # tr
    #
    assert_equal "123defg", "abcdefg".tr("abc", "123")
    assert_equal "123d456", "abcdefg".tr("abcefg", "123456")
    assert_equal "123333g", "abcdefg".tr("abcdef", "123")

    assert_equal "123defg", "abcdefg".tr("a-c", "123")
    assert_equal "123d456", "abcdefg".tr("a-ce-g", "123456")
    assert_equal "123d456", "abcdefg".tr("a-cefg", "123456")

    assert_equal "143defg", "abcdefg".tr("a-cb", "123456")
    assert_equal "143de56", "abcdefg".tr("a-cbfg", "123456")
    assert_equal "14567fg", "abcdefg".tr("a-cb-e", "123456789")

    assert_equal "a999999", "abcdefg".tr("^a", "123456789")
    assert_equal "abc9999", "abcdefg".tr("^abc", "123456789")
    assert_equal "abc9999", "abcdefg".tr("^a-c", "123456789")
    assert_equal "^23defg", "abcdefg".tr("abc", "^23456789")

    # Illegal Cases
    assert_equal "abcdefg", "abcdefg".tr("", "123456789")
    assert_equal "abc1defg", "abc^defg".tr("^", "123456789")
    assert_equal "abc1defg", "abc-defg".tr("-", "123456789")
    assert_equal "1bc2defg", "abc-defg".tr("a-", "123456789")
    assert_equal "123-defg", "abc-defg".tr("a-c", "123456789")
    assert_equal "ab21defg", "abc-defg".tr("-c", "123456789")

    # delete
    assert_equal "defg", "abcdefg".tr("abc", "")
    assert_equal "abc", "abcdefg".tr("^abc", "")

    # range replace
    assert_equal "FOO", "foo".tr("a-z", "A-Z")
    assert_equal "foo", "FOO".tr("A-Z", "a-z")
    assert_equal "12cABC", "abcdef".tr("abd-f", "12A-C")

    #
    # start_with?
    #
    assert_true "abc".start_with?("")
    assert_true "abc".start_with?("a")
    assert_true "abc".start_with?("ab")
    assert_true "abc".start_with?("abc")
    assert_false "abc".start_with?("abcd")
    assert_false "abc".start_with?("A")
    assert_false "abc".start_with?("aA")
    assert_false "abc".start_with?("b")

    #
    # end_with?
    #
    assert_true "abc".end_with?("")
    assert_true "abc".end_with?("c")
    assert_true "abc".end_with?("bc")
    assert_true "abc".end_with?("abc")
    assert_false "abc".end_with?(" abc")
    assert_false "abc".end_with?("C")
    assert_false "abc".end_with?("Bc")
    assert_false "abc".end_with?("b")

    #
    # include?
    #
    assert_true "abc".include?("")
    assert_true "abc".include?("a")
    assert_true "abc".include?("b")
    assert_true "abc".include?("c")
    assert_true "abc".include?("ab")
    assert_true "abc".include?("bc")
    assert_true "abc".include?("abc")
    assert_false "abc".include?("abcd")
    assert_false "abc".include?(" abc")
    assert_false "abc".include?("A")
    assert_false "abc".include?("aB")
    assert_false "abc".include?("abC")

    #
    # to_f, to_i, to_s
    #
    assert_equal 10.0, "10".to_f
    assert_equal 1000.0, "10e2".to_f
    assert_equal 0.01, "1e-2".to_f
    assert_equal 0.1, ".1".to_f

    # not support this case.
    #assert_equal 0.0, "nan".to_f
    #assert_equal 0.0, "INF".to_f
    #assert_equal( -0.0, "-Inf".to_f )

    assert_equal 0.0, "".to_f
    #assert_equal 100.0, "1_0_0".to_f
    assert_equal 10.0, " \n10".to_f
    #assert_equal 0.0, "0xa.a".to_f

    assert_equal 10, " 10".to_i
    assert_equal 10, "+10".to_i
    assert_equal(-10, "-10".to_i)

    assert_equal 10, "010".to_i
    assert_equal(-10, "-010".to_i)

    assert_equal 0, "0x11".to_i
    assert_equal 0, "".to_i

    assert_equal 1, "01".to_i(2)
    #assert_equal 1, "0b1".to_i(2)

    assert_equal 7, "07".to_i(8)
    #assert_equal 7, "0o7".to_i(8)

    assert_equal 31, "1f".to_i(16)
    #assert_equal 31, "0x1f".to_i(16)

    # not support this case.
    #assert_equal 2, "0b10".to_i(0)
    #assert_equal 8, "0o10".to_i(0)
    #assert_equal 8, "010".to_i(0)
    #assert_equal 10, "0d10".to_i(0)
    #assert_equal 16, "0x10".to_i(0)

    assert_equal "str", "str".to_s
  end
end

# frozen_string_literal: true

class Test < MrubycTestCase
  description ""

  def all
  end
end

# frozen_string_literal: true

class BoolTest < MrubycTestCase
  description "Bool"

  def all

    # coding: utf-8
    # true / false
    v = true
    assert_true(v)

    v = false
    assert_false(v)

    v = nil
    assert_false(v)

    v = 0
    assert_true(v)

    v = 1
    assert_true(v)

    v = 0.0
    assert_true(v)

    v = 0.0 / 0
    assert_true(v)

    v = "0"
    assert_true(v)

    v = ""
    assert_true(v)

    v = []
    assert_true(v)

    v = :sym
    assert_true(v)

    ##### !演算子 #####
    v = true
    assert_false(!v)

    v = false
    assert_true(!v)

    v = nil
    assert_true(!v)

    v = 0
    assert_false(!v)

    v = 1
    assert_false(!v)

    v = 0.0
    assert_false(!v)

    v = 0.0 / 0
    assert_false(!v)

    v = "0"
    assert_false(!v)

    v = ""
    assert_false(!v)

    v = []
    assert_false(!v)

    v = :sym
    assert_false(!v)

    ##### !=演算子 #####

    v1, v2 = true, true
    assert_equal(v1, v2)

    v1, v2 = true, false
    assert_not_equal(v1, v2)

    v1, v2 = false, true
    assert_not_equal(v1, v2)

    v1, v2 = false, false
    assert_equal(v1, v2)

    v1, v2 = true, nil
    assert_not_equal(v1, v2)

    v1, v2 = nil, true
    assert_not_equal(v1, v2)

    v1, v2 = false, nil
    assert_not_equal(v1, v2)

    v1, v2 = nil, false
    assert_not_equal(v1, v2)
  end
end

# frozen_string_literal: true

class OpBasicTest < MrubycTestCase
  description "OP CODE basic"

  def all

    # coding: utf-8
    #
    # IREPオペコード　基本演算テスト

    # op_add
    a = 1
    b = 2
    assert_equal(a + b, 3)

    a = 1
    b = 2.0
    assert_equal(a + b, 3.0)

    a = 1.0
    b = 2
    assert_equal(a + b, 3.0)

    a = 1.0
    b = 2.0
    assert_equal(a + b, 3.0)

    # op_addi
    a = 1
    assert_equal(a + 2, 3)
    assert_equal(1 + 2, 3)

    a = 1.0
    assert_equal(a + 2, 3.0)
    assert_equal(1.0 + 2, 3.0)

    # op_sub
    a = 1
    b = 2
    assert_equal(a - b, -1)

    a = 1
    b = 2.0
    assert_equal(a - b, -1.0)

    a = 1.0
    b = 2
    assert_equal(a - b, -1.0)

    a = 1.0
    b = 2.0
    assert_equal(a - b, -1.0)

    # op_subi
    a = 1
    assert_equal(a - 2, -1)

    a = 1.0
    assert_equal(a - 2, -1.0)

    # op_mul
    a = 2
    b = 3
    assert_equal a * b, 6

    a = 2
    b = 3.0
    assert_equal a * b, 6.0

    a = 2.0
    b = 3
    assert_equal a * b, 6.0

    a = 2.0
    b = 3.0
    assert_equal a * b, 6.0

    # op_lt
    a = 1
    b = 2
    assert_true(a < b)
    assert_false(b < a)

    a = 1
    b = 2.0
    assert_true(a < b)
    assert_false(b < a)

    a = 1.0
    b = 2
    assert_true(a < b)
    assert_false(b < a)

    a = 1.0
    b = 2.0
    assert_true(a < b)
    assert_false(b < a)

    a = 1
    b = 1
    assert_false(a < b)

    a = 1
    b = 1.0
    assert_false(a < b)

    a = 1.0
    b = 1
    assert_false(a < b)

    a = 1.0
    b = 1.0
    assert_false(a < b)

    # op_le
    a = 1
    b = 2
    assert_true(a <= b)
    assert_false(b <= a)

    a = 1
    b = 2.0
    assert_true(a <= b)
    assert_false(b <= a)

    a = 1.0
    b = 2
    assert_true(a <= b)
    assert_false(b <= a)

    a = 1.0
    b = 2.0
    assert_true(a <= b)
    assert_false(b <= a)

    a = 1
    b = 1
    assert_true(a <= b)

    a = 1
    b = 1.0
    assert_true(a <= b)

    a = 1.0
    b = 1
    assert_true(a <= b)

    a = 1.0
    b = 1.0
    assert_true(a <= b)

    # op_gt
    a = 1
    b = 2
    assert_false(a > b)
    assert_true(b > a)

    a = 1
    b = 2.0
    assert_false(a > b)
    assert_true(b > a)

    a = 1.0
    b = 2
    assert_false(a > b)
    assert_true(b > a)

    a = 1.0
    b = 2.0
    assert_false(a > b)
    assert_true(b > a)

    a = 1
    b = 1
    assert_false(a > b)

    a = 1
    b = 1.0
    assert_false(a > b)

    a = 1.0
    b = 1
    assert_false(a > b)

    a = 1.0
    b = 1.0
    assert_false(a > b)

    # op_ge
    a = 1
    b = 2
    assert_false(a >= b)
    assert_true(b >= a)

    a = 1
    b = 2.0
    assert_false(a >= b)
    assert_true(b >= a)

    a = 1.0
    b = 2
    assert_false(a >= b)
    assert_true(b >= a)

    a = 1.0
    b = 2.0
    assert_false(a >= b)
    assert_true(b >= a)

    a = 1
    b = 1
    assert_true(a >= b)

    a = 1
    b = 1.0
    assert_true(a >= b)

    a = 1.0
    b = 1
    assert_true(a >= b)

    a = 1.0
    b = 1.0
    assert_true(a >= b)
  end
end

# frozen_string_literal: true

class NilClassTest < MrubycTestCase
  description "NilClass class"

  def all

    # coding: utf-8

    assert_equal(true, nil.nil?)

    assert_equal(0, nil.to_i)
    assert_equal("", nil.to_s)
    assert_equal(0.0, nil.to_f)
    assert_equal([], nil.to_a)
    assert_equal({}, nil.to_h)

    #assert_equal( false, nil & true )
    #assert_equal( false, nil & false )
    #assert_equal( true,  nil ^ true )
    #assert_equal( false, nil ^ false )
    #assert_equal( true,  nil | true )
    #assert_equal( false, nil | false )
  end
end

# frozen_string_literal: true

class RangeTest < MrubycTestCase
  description "Range class"

  def all

    # range

    assert_equal (1..2), (1..2)
    assert_not_equal (1..2), (1...2)
    assert_not_equal (1..2), (1..3)
    assert_not_equal (1..3), (2..3)

    #
    # range#=== operator
    #

    r = (1..3)
    assert_false r === 0
    assert_true r === 1
    assert_true r === 2
    assert_true r === 3
    assert_false r === 4

    r = (1...3)
    assert_false r === 0
    assert_true r === 1
    assert_true r === 2
    assert_false r === 3
    assert_false r === 4
  end
end

# frozen_string_literal: true

class OpMethodTest < MrubycTestCase
  description "OP CODE method"

  def all

    # coding: utf-8
    #
    # メソッドで実行される演算子のテスト
    # 　単項論理演算子 ! は、test_boolへ
    #　 ===　演算子は、test_equal3へ
    #　 <=>　演算子は、test_compareへ

    # 単項 +, -
    a = 123
    assert_equal(123, +123)
    #assert_equal( 123, +a )        # 実装が必要か怪しい
    assert_equal(-123, -a)

    a = 2.72
    assert_equal(2.72, 2.72)
    #assert_equal( 2.72, +a )
    assert_equal(-2.72, -a)

    # 剰余
    a = 123
    assert_equal(3, 123 % 12)
    assert_equal(3, a % 12)

    # ビット演算
    a = 0x15a0
    assert_equal(-5537, ~a)

    assert_equal(0x01, 0x01 << 0)
    assert_equal(0x02, 0x01 << 1)
    assert_equal(0x04, 0x01 << 2)
    assert_equal(0x8000_0000, 0x01 << 31)
    assert_equal(0, 0x01 << 32)   # when 32bit mrbc_int

    assert_equal(0x4000_0000, 0x4000_0000 >> 0)
    assert_equal(0x2000_0000, 0x4000_0000 >> 1)
    assert_equal(0, 0x4000_0000 >> 32)

    assert_equal(0x0034, 0x1234 & 0x00ff)
    assert_equal(0x12ff, 0x1234 | 0x00ff)
    assert_equal(0x12cb, 0x1234 ^ 0x00ff)

    # 論理演算子
    #  == (op_eq)
    assert_true(1 == 1)
    assert_false(1 == 2)
    assert_true(1 == 1.0)
    assert_true(1.0 == 1)
    assert_true(1.0 == 1.0)

    # !=
    assert_true(1 != 2)
    assert_false(1 != 1)
    assert_true(1 != 2.0)
    assert_true(1.0 != 2)
    assert_true(1.0 != 2.0)

    # &&
    assert_equal(2, 1 && 2)
    assert_equal(false, 1 && false)
    assert_equal(nil, 1 && nil)
    assert_equal(false, false && 2)
    assert_equal(nil, nil && 2)
    assert_equal(nil, nil && false)

    # ||
    assert_equal(1, 1 || 2)
    assert_equal(1, 1 || false)
    assert_equal(1, 1 || nil)
    assert_equal(2, false || 2)
    assert_equal(2, nil || 2)
    assert_equal(false, nil || false)
  end
end

# frozen_string_literal: true

class SprintfTest < MrubycTestCase
  description "spintf"

  def all

    # coding: utf-8
    #
    # sprintf
    #

    #
    # sprintf "%c"
    #
    assert_equal "A", sprintf("%c", 65)
    assert_equal "A", sprintf("%c", "A")

    # width
    assert_equal "  A", sprintf("%3c", 65)

    # flag '-'
    assert_equal "A  ", sprintf("%-3c", 65)
    assert_equal "A", sprintf("%-c", 65)

    #
    # sprintf "%s"
    #
    assert_equal "ABC", sprintf("%s", "ABC")

    # width
    assert_equal "  ABC", sprintf("%5s", "ABC")
    assert_equal "ABCDE", sprintf("%5s", "ABCDE")
    assert_equal "ABCDEF", sprintf("%5s", "ABCDEF")

    # precision
    assert_equal "ABCDE", sprintf("%.5s", "ABCDEF")
    assert_equal "ABC", sprintf("%.5s", "ABC")

    # flag '-'
    assert_equal "ABC  ", sprintf("%-5s", "ABC")
    assert_equal "ABC", sprintf("%-s", "ABC")

    # width, precision, flag '-'
    assert_equal "  ABC", sprintf("%5.5s", "ABC")
    assert_equal "ABC  ", sprintf("%-5.5s", "ABC")
    assert_equal "ABCDE", sprintf("%5.5s", "ABCDEFG")
    assert_equal "     ABCDE", sprintf("%10.5s", "ABCDEFG")
    assert_equal "ABCDE     ", sprintf("%-10.5s", "ABCDEFG")

    #
    # sprintf "%d", "%i"
    #
    assert_equal "123", sprintf("%d", 123)
    assert_equal "123", sprintf("%i", 123)
    assert_equal "-123", sprintf("%d", -123)

    # width
    assert_equal "  123", sprintf("%5d", 123)
    assert_equal "12345", sprintf("%5d", 12345)
    assert_equal "123456", sprintf("%5d", 123456)
    assert_equal " -123", sprintf("%5d", -123)
    assert_equal "-1234", sprintf("%5d", -1234)
    assert_equal "-12345", sprintf("%5d", -12345)

    # precision
    assert_equal "   01", sprintf("%5.2d", 1)
    assert_equal "  123", sprintf("%5.2d", 123)
    assert_equal "00123", sprintf("%5.5d", 123)
    assert_equal "12345", sprintf("%5.5d", 12345)
    assert_equal "123456", sprintf("%5.5d", 123456)
    assert_equal "00001", sprintf("%3.5d", 1)
    assert_equal "12345", sprintf("%3.5d", 12345)
    assert_equal "123456", sprintf("%3.5d", 123456)

    assert_equal "  -01", sprintf("%5.2d", -1)
    assert_equal "  -12", sprintf("%5.2d", -12)
    assert_equal " -123", sprintf("%5.2d", -123)

    # flag '+'
    assert_equal "+1", sprintf("%+d", 1)
    assert_equal "-1", sprintf("%+d", -1)
    assert_equal "+0", sprintf("%+d", 0)
    assert_equal "+12", sprintf("%+3d", 12)
    assert_equal "+123", sprintf("%+3d", 123)

    assert_equal "  +01", sprintf("%+5.2d", 1)
    assert_equal "  -01", sprintf("%+5.2d", -1)

    # flag ' '
    assert_equal " 1", sprintf("% d", 1)
    assert_equal "-1", sprintf("% d", -1)
    assert_equal " 0", sprintf("% d", 0)
    assert_equal " 12", sprintf("% 3d", 12)
    assert_equal " 123", sprintf("% 3d", 123)
    assert_equal "-12", sprintf("% 3d", -12)
    assert_equal "-123", sprintf("% 3d", -123)

    # flag '0'
    assert_equal "001", sprintf("%03d", 1)
    assert_equal "123", sprintf("%03d", 123)
    assert_equal "1234", sprintf("%03d", 1234)

    #
    # sprintf "%u"
    #
    assert_equal "-1", sprintf("%u", -1)

    #
    # sprintf "%x", "%X"
    #
    assert_equal "0", sprintf("%x", 0)
    assert_equal "a", sprintf("%x", 10)
    assert_equal "A", sprintf("%X", 10)

    assert_equal "..F", sprintf("%X", -1)
    assert_equal "..FB2E", sprintf("%X", -1234)
    assert_equal "..FCFC7", sprintf("%X", -12345)

    # width
    assert_equal "   0", sprintf("%4X", 0)
    assert_equal "   A", sprintf("%4X", 10)
    assert_equal "FFFF", sprintf("%4X", 0xffff)
    assert_equal "10000", sprintf("%4X", 0x10000)

    assert_equal " ..f", sprintf("%4x", -1)
    assert_equal "..f4", sprintf("%4x", -12)
    assert_equal "..f85", sprintf("%4x", -123)

    # flag '-'
    assert_equal "0   ", sprintf("%-4x", 0)
    assert_equal "1   ", sprintf("%-4x", 1)
    assert_equal "FFFF", sprintf("%-4X", 0xffff)
    assert_equal "10000", sprintf("%-4X", 0x10000)

    assert_equal "..f ", sprintf("%-4x", -1)
    assert_equal "..f4", sprintf("%-4x", -12)
    assert_equal "..f85", sprintf("%-4x", -123)

    # flag '0'
    assert_equal "0000", sprintf("%04X", 0x0)
    assert_equal "0010", sprintf("%04X", 0x10)
    assert_equal "1111", sprintf("%04X", 0x1111)
    assert_equal "10000", sprintf("%04X", 0x10000)

    # no compatibility with cruby and mruby.
    assert_equal "ffff", sprintf("%04x", -1)
    assert_equal "fff4", sprintf("%04x", -12)
    assert_equal "ff85", sprintf("%04x", -123)
    assert_equal "fb2e", sprintf("%04x", -1234)
    assert_equal "cfc7", sprintf("%04x", -12345)

    #
    # sprintf "%b", "%B"
    #
    assert_equal "0", sprintf("%b", 0)
    assert_equal "1", sprintf("%b", 1)
    assert_equal "10", sprintf("%b", 2)
    assert_equal "11", sprintf("%b", 3)
    assert_equal "100", sprintf("%b", 4)
    assert_equal "101", sprintf("%b", 5)
    assert_equal "1", sprintf("%B", 1)

    assert_equal "..1", sprintf("%b", -1)
    assert_equal "..10", sprintf("%b", -2)
    assert_equal "..101", sprintf("%b", -3)
    assert_equal "..100", sprintf("%b", -4)
    assert_equal "..1011", sprintf("%b", -5)

    # width
    assert_equal "   0", sprintf("%4b", 0)
    assert_equal "   1", sprintf("%4b", 1)
    assert_equal "1111", sprintf("%4b", 15)
    assert_equal "10000", sprintf("%4b", 16)

    assert_equal " ..1", sprintf("%4b", -1)
    assert_equal "..10", sprintf("%4b", -2)
    assert_equal "..100", sprintf("%4b", -4)

    # flag '-'
    assert_equal "0   ", sprintf("%-4b", 0)
    assert_equal "1   ", sprintf("%-4b", 1)
    assert_equal "1111", sprintf("%-4b", 15)
    assert_equal "10000", sprintf("%-4b", 16)

    assert_equal "..1 ", sprintf("%-4b", -1)
    assert_equal "..10", sprintf("%-4b", -2)
    assert_equal "..100", sprintf("%-4b", -4)

    # flag '0'
    assert_equal "0000", sprintf("%04b", 0)
    assert_equal "0001", sprintf("%04b", 1)
    assert_equal "1111", sprintf("%04b", 15)
    assert_equal "10000", sprintf("%04b", 16)

    # no compatibility with cruby and mruby.
    assert_equal "1111", sprintf("%04b", -1)
    assert_equal "1000", sprintf("%04b", -8)
    assert_equal "0111", sprintf("%04b", -9)
  end
end

# frozen_string_literal: true

class StringSplitTest < MrubycTestCase
  description "String#split"

  def all

    #
    # String#split
    #

    #
    # Regex  not supprted.
    #

    #
    # String
    #
    assert_equal ["a", "b", "c"], "a,b,c".split(",")
    assert_equal ["a", "", "b", "c"], "a,,b,c".split(",")
    assert_equal ["a", "b:c", "d"], "a::b:c::d".split("::")
    assert_equal ["a", "b:c", "d:"], "a::b:c::d:".split("::")
    assert_equal ["a", "b:c", "d"], "a::b:c::d::".split("::")
    assert_equal ["a", "b:c", "d", ":"], "a::b:c::d:::".split("::")

    #
    # " "
    #
    assert_equal ["a", "b", "c"], "   a \t  b \n  c\r\n".split(" ")
    assert_equal ["a", "b", "c"], "a \t  b \n  c\r\n".split(" ")
    assert_equal ["a", "b", "c"], "   a \t  b \n  c".split(" ")
    assert_equal ["a", "b", "c"], "a \t  b \n  c".split(" ")
    assert_equal ["aa", "bb", "cc"], " aa bb cc ".split(" ")
    assert_equal ["aa", "bb", "cc"], "aa bb cc ".split(" ")
    assert_equal ["aa", "bb", "cc"], " aa bb cc".split(" ")
    assert_equal ["aa", "bb", "cc"], "aa bb cc".split(" ")

    #
    # nil
    #
    assert_equal ["a", "b", "c"], "   a \t  b \n  c".split()
    assert_equal ["a", "b", "c"], "   a \t  b \n  c".split(nil)

    #
    # "" (empty string)
    #
    assert_equal [" ", " ", " ", "a", " ", "\t", " ", " ", "b", " ", "\n", " ", " ", "c"], "   a \t  b \n  c".split("")

    #
    # limit
    #
    assert_equal ["a", "b", "", "c"], "a,b,,c,,".split(",", 0)
    assert_equal ["a,b,,c,,"], "a,b,,c,,".split(",", 1)
    assert_equal ["a", "b,,c,,"], "a,b,,c,,".split(",", 2)
    assert_equal ["a", "b", ",c,,"], "a,b,,c,,".split(",", 3)
    assert_equal ["a", "b", "", "c,,"], "a,b,,c,,".split(",", 4)
    assert_equal ["a", "b", "", "c", ","], "a,b,,c,,".split(",", 5)
    assert_equal ["a", "b", "", "c", "", ""], "a,b,,c,,".split(",", 6)
    assert_equal ["a", "b", "", "c", "", ""], "a,b,,c,,".split(",", 7)
    assert_equal ["a", "b", "", "c", "", ""], "a,b,,c,,".split(",", -1)
    assert_equal ["a", "b", "", "c", "", ""], "a,b,,c,,".split(",", -2)

    assert_equal ["aa", "bb", "cc"], " aa  bb  cc ".split(" ", 0)
    assert_equal [" aa  bb  cc "], " aa  bb  cc ".split(" ", 1)
    assert_equal ["aa", "bb  cc "], " aa  bb  cc ".split(" ", 2)
    assert_equal ["aa", "bb", "cc "], " aa  bb  cc ".split(" ", 3)
    assert_equal ["aa", "bb", "cc", ""], " aa  bb  cc ".split(" ", 4)
    assert_equal ["aa", "bb", "cc", ""], " aa  bb  cc ".split(" ", 5)
    assert_equal ["aa", "bb", "cc", ""], " aa  bb  cc ".split(" ", -1)

    assert_equal ["aa", "bb", "cc"], "aa  bb  cc".split(" ", 0)
    assert_equal ["aa  bb  cc"], "aa  bb  cc".split(" ", 1)
    assert_equal ["aa", "bb  cc"], "aa  bb  cc".split(" ", 2)
    assert_equal ["aa", "bb", "cc"], "aa  bb  cc".split(" ", 3)
    assert_equal ["aa", "bb", "cc"], "aa  bb  cc".split(" ", 4)
    assert_equal ["aa", "bb", "cc"], "aa  bb  cc".split(" ", -1)

    #
    # empty source
    #
    assert_equal [], "".split(",")
    assert_equal [], "".split(",", 0)
    assert_equal [], "".split(",", 1)
    assert_equal [], "".split(",", -1)

    assert_equal [], "".split("")
    assert_equal [], "".split("", 0)
    assert_equal [], "".split("", 1)
    assert_equal [], "".split("", -1)

    assert_equal [], "".split(" ")
    assert_equal [], "".split(" ", 0)
    assert_equal [], "".split(" ", 1)
    assert_equal [], "".split(" ", -1)

    #
    # delimiter only
    #
    assert_equal [], ",".split(",")
    assert_equal [], ",".split(",", 0)
    assert_equal [","], ",".split(",", 1)
    assert_equal ["", ""], ",".split(",", -1)

    assert_equal [], ",,".split(",")
    assert_equal [], ",,".split(",", 0)
    assert_equal [",,"], ",,".split(",", 1)
    assert_equal ["", "", ""], ",,".split(",", -1)

    assert_equal [], " ".split(" ")
    assert_equal [], " ".split(" ", 0)
    assert_equal [" "], " ".split(" ", 1)
    assert_equal [""], " ".split(" ", -1)

    assert_equal [], "  ".split(" ")
    assert_equal [], "  ".split(" ", 0)
    assert_equal ["  "], "  ".split(" ", 1)
    assert_equal [""], "  ".split(" ", -1)
  end
end

# frozen_string_literal: true

class ObjectTest < MrubycTestCase
  description "Object class"

  def all

    # nil?
    assert_equal true, nil.nil?
    assert_equal false, true.nil?
    assert_equal false, false.nil?
  end
end

# frozen_string_literal: true

class ArrayTest < MrubycTestCase
  description "Array class"

  def all

    #
    # operator +
    #
    assert_equal [1, 2, 3, 4], [1, 2] + [3, 4]
    a = [1, 2, 3]
    b = a + [4, 5]
    assert_equal [1, 2, 3], a
    assert_equal [1, 2, 3, 4, 5], b
    a += b
    assert_equal [1, 2, 3, 1, 2, 3, 4, 5], a
    assert_equal [1, 2, 3, 4, 5], b

    #
    # size, length, empty, clear
    #
    a = [0, 1, 2, 3, 4]
    e = []
    assert_equal 5, a.size
    assert_equal 5, a.length
    assert_equal 5, a.count
    assert_equal 0, e.size

    assert_equal a, a
    assert_equal [0, 1, 2, 3, 4], a
    assert_equal e, e
    assert_equal [], e

    assert_equal false, a != a
    assert_equal true, a != e

    assert_equal true, e.empty?
    assert_equal false, a.empty?

    assert_equal [], a.clear
    assert_equal [], a
    assert_equal true, a.empty?

    #
    # constructor
    #
    assert_equal [], Array.new
    assert_equal [nil, nil, nil, nil, nil], Array.new(5)
    assert_equal [0, 0, 0, 0, 0], Array.new(5, 0)
    assert_equal ["AB", "CD", "E"], %w(AB CD E)
    assert_equal [:AB, :CD, :E], %i(AB CD E)

    #
    # setter
    #
    assert_equal 0, a[0] = 0
    assert_equal [0], a
    a[1] = 1
    assert_equal [0, 1], a
    a[3] = 3
    assert_equal [0, 1, nil, 3], a
    a[0] = 99
    assert_equal [99, 1, nil, 3], a
    a[1] = 88
    assert_equal [99, 88, nil, 3], a

    a[-1] = 77
    assert_equal [99, 88, nil, 77], a
    a[-2] = 66
    assert_equal [99, 88, 66, 77], a

    #
    # getter
    #
    a = [1, 2, 3, 4]
    assert_equal 1, a[0]
    assert_equal 1, a.at(0)
    assert_equal 2, a[1]
    assert_equal 3, a[2]
    assert_equal 4, a[3]
    assert_equal nil, a[4]

    assert_equal 4, a[-1]
    assert_equal 3, a[-2]
    assert_equal 2, a[-3]
    assert_equal 1, a[-4]
    assert_equal nil, a[-5]

    assert_equal [2, 3], a[1, 2]
    assert_equal [2, 3, 4], a[1, 10000]
    assert_equal [4], a[3, 1]
    assert_equal [4], a[3, 2]
    assert_equal nil, a[10000, 2]
    assert_equal nil, a[10000, 10000]

    assert_equal [2, 3], a[-3, 2]
    assert_equal [2, 3, 4], a[-3, 10000]
    assert_equal [1], a[-4, 1]
    assert_equal nil, a[-5, 1]
    assert_equal nil, a[-10000, 1]
    assert_equal nil, a[-10000, 10000]
    assert_equal nil, a[-10000, -10000]

    #
    # index / first / last
    #
    a = [1, 2, 3, 4]
    assert_equal 1, a.index(2)
    assert_equal nil, a.index(0)
    assert_equal nil, e.index(9)

    assert_equal 1, a.first
    assert_equal 4, a.last
    assert_equal nil, e.first
    assert_equal nil, e.last

    #
    # delete_at
    #
    assert_equal 1, a.delete_at(0)
    assert_equal [2, 3, 4], a
    assert_equal 3, a.delete_at(1)
    assert_equal [2, 4], a
    assert_equal 4, a.delete_at(-1)
    assert_equal [2], a

    #
    # push / pop
    #
    a = []
    assert_equal [1], a.push(1)
    assert_equal [1, 2], a.push(2)
    assert_equal [1, 2], a

    assert_equal 2, a.pop()
    assert_equal [1], a
    assert_equal 1, a.pop()
    assert_equal [], a
    assert_equal nil, a.pop()
    assert_equal [], a

    a = []
    assert_equal [1], a << 1
    assert_equal [1, 2], a << 2
    assert_equal [1, 2], a

    #
    # unshift / shift
    #
    a = []
    assert_equal [1], a.unshift(1)
    assert_equal [2, 1], a.unshift(2)
    assert_equal [2, 1], a

    assert_equal 2, a.shift()
    assert_equal [1], a
    assert_equal 1, a.shift()
    assert_equal [], a
    assert_equal nil, a.shift()
    assert_equal [], a

    #
    # dup
    #
    a = [1, 2, 3]
    b = a
    a[0] = 11
    assert_equal a, b
    assert_equal [11, 2, 3], b

    a = [1, 2, 3]
    b = a.dup
    a[0] = 11
    assert_not_equal a, b
    assert_equal [11, 2, 3], a
    assert_equal [1, 2, 3], b

    #
    # min, max, minmax
    #
    a = %w(albatross dog horse)
    assert_equal "albatross", a.min
    assert_equal "horse", a.max
    assert_equal ["albatross", "horse"], a.minmax

    a = ["AAA"]
    assert_equal "AAA", a.min
    assert_equal "AAA", a.max
    assert_equal ["AAA", "AAA"], a.minmax

    a = []
    assert_equal nil, a.min
    assert_equal nil, a.max
    assert_equal [nil, nil], a.minmax

    #
    # inspect, to_s, join
    #
    a = [1, 2, 3]
    assert_equal "[1, 2, 3]", a.inspect
    assert_equal "[1, 2, 3]", a.to_s
    assert_equal "123", a.join
    assert_equal "1,2,3", a.join(",")
    assert_equal "1, 2, 3", a.join(", ")

    array = [1, "AA", :sym]
    hash = { 1 => 1, :k2 => :v2, "k3" => "v3" }
    range = 1..3
    a = [nil, false, true, 123, 2.718, :symbol, array, "string", range, hash]
    assert_equal %q![nil, false, true, 123, 2.718, :symbol, [1, "AA", :sym], "string", 1..3, {1=>1, :k2=>:v2, "k3"=>"v3"}]!, a.inspect
    assert_equal %q![nil, false, true, 123, 2.718, :symbol, [1, "AA", :sym], "string", 1..3, {1=>1, :k2=>:v2, "k3"=>"v3"}]!, a.to_s
    assert_equal %q!,false,true,123,2.718,symbol,1,AA,sym,string,1..3,{1=>1, :k2=>:v2, "k3"=>"v3"}!, a.join(",")

    #
    # each
    #
    a = [1, 2, 3]
    $cnt = 0
    a.each { |a1|
      $cnt += 1
      assert_equal a1, $cnt
    }
    assert_equal 3, $cnt

    $cnt = 0
    a.each_index { |i|
      assert_equal i, $cnt
      $cnt += 1
      assert_equal a[i], $cnt
    }
    assert_equal 3, $cnt

    $cnt = 0
    a.each_with_index { |a1, i|
      $cnt += 1
      assert_equal a1, $cnt
      assert_equal a[i], $cnt
    }
    assert_equal 3, $cnt

    #
    # collect
    #
    a = [1, 2, 3]
    assert_equal [2, 4, 6], a.collect { |a1| a1 * 2 }
    assert_equal [1, 2, 3], a

    a.collect! { |a1| a1 * 2 }
    assert_equal [2, 4, 6], a
  end
end

# frozen_string_literal: true

class SymbolTest < MrubycTestCase
  description "Symbol class"

  def all

    # coding: utf-8
    # symbol test

    # 生成
    s = :symbol
    assert_equal :symbol, s

    # 比較
    assert_equal true, s == :symbol
    assert_equal false, s == :symbol2
    assert_equal false, s != :symbol
    assert_equal true, s != :symbol2

    # to_sym
    s = "abc"
    assert_equal :abc, s.to_sym
    assert_not_equal :abc, s

    # to_s
    s = :symbol
    assert_equal "symbol", s.to_s
    assert_not_equal "symbol", s
  end
end

# frozen_string_literal: true

class HashTest < MrubycTestCase
  description "Hash class"

  def all

    # coding: utf-8

    # 生成
    h = { a: 1, b: 2 }
    assert_equal({ :a => 1, :b => 2 }, h)

    h = Hash.new
    assert_equal({}, h)

    # 値の取り出し
    h = { :key => "value", "key" => :value, 3 => "Three", :"4" => 444 }
    assert_equal("value", h[:key])
    assert_equal(:value, h["key"])
    assert_equal("Three", h[3])
    assert_equal(444, h[:"4"])

    # 値の設定、サイズ
    h = Hash.new
    assert_equal(0, h.size)
    h["key"] = :value
    assert_equal(:value, h["key"])
    assert_equal(1, h.size)

    # Hash#[]: 存在しないキーにアクセスした場合nilが返ること
    assert_equal(nil, h["no-exist-key"])

    # operator !=
    h1 = { :key => "value", "key" => :value, 3 => "Three", :"4" => 444 }
    assert_not_equal(h, h1)

    # operator ==  (順序が違うHash同士の比較)
    h[:key] = "value"
    h[:"4"] = 444
    h[3] = "Three"
    assert_equal(h, h1)

    assert_equal(4, h.size)
    assert_equal(4, h1.size)

    # 値の上書き
    h[:key] = "other value"
    assert_not_equal(h, h1)
    assert_equal(4, h.size)

    # clear
    h.clear
    assert_equal({}, h)
    assert_equal(0, h.size)

    # dup
    h = { :a => "A", :b => "B" }
    h1 = h
    assert_equal(h, h1)

    h1[:a] = "AA"
    assert_equal(h, h1)

    h1 = h.dup
    h1[:b] = "BB"
    assert_not_equal(h, h1)

    # delete
    h = { :ab => "some", :cd => "all" }

    assert_equal("some", h.delete(:ab))
    assert_equal(h, { :cd => "all" })

    assert_equal(nil, h.delete(:ef))

    # TODO delete with block

    # empty?
    assert_equal(true, {}.empty?)
    assert_equal(false, { :a => 1 }.empty?)

    # has_key?
    h = { :key => "value", "key" => :value, 3 => "Three", :"4" => 444 }
    assert_equal(true, h.has_key?(:key))
    assert_equal(false, h.has_key?(:key2))

    # has_value?
    assert_equal(true, h.has_value?(444))
    assert_equal(false, h.has_value?(555))

    # key
    assert_equal("key", h.key(:value))
    assert_equal(nil, h.key(:no_exist))

    # keys
    assert_equal([:key, "key", 3, :"4"], h.keys)

    # values
    assert_equal(["value", :value, "Three", 444], h.values)

    # size, length, count
    assert_equal(4, h.size)
    assert_equal(4, h.length)
    assert_equal(4, h.count)

    # merge
    foo = { 1 => "a", 2 => "b", 3 => "c" }
    bar = { 2 => "B", 3 => "C", 4 => "D" }
    assert_equal({ 1 => "a", 2 => "B", 3 => "C", 4 => "D" }, foo.merge(bar))
    assert_equal({ 1 => "a", 2 => "b", 3 => "c" }, foo)
    assert_equal({ 2 => "B", 3 => "C", 4 => "D" }, bar)

    # merge!
    assert_equal({ 1 => "a", 2 => "B", 3 => "C", 4 => "D" }, foo.merge!(bar))
    assert_equal({ 1 => "a", 2 => "B", 3 => "C", 4 => "D" }, foo)
    assert_equal({ 2 => "B", 3 => "C", 4 => "D" }, bar)

    # to_h
    h = {}
    assert_equal({}, h.to_h)
  end
end

information = { :test_class_name => "StringStripTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/string_strip_test.rb", :line => 5, :description => "String#strip" }
my_case = StringStripTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "FixnumTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/fixnum_test.rb", :line => 6, :description => "Fixnum" }
my_case = FixnumTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "StringTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/string_test.rb", :line => 5, :description => "String class" }
my_case = StringTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "Test", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/_test.rb", :line => 6, :description => "" }
my_case = Test.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "BoolTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/bool_test.rb", :line => 6, :description => "Bool" }
my_case = BoolTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "OpBasicTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/op_basic_test.rb", :line => 6, :description => "OP CODE basic" }
my_case = OpBasicTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "NilClassTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/nil_class_test.rb", :line => 6, :description => "NilClass class" }
my_case = NilClassTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "RangeTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/range_test.rb", :line => 6, :description => "Range class" }
my_case = RangeTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "OpMethodTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/op_method_test.rb", :line => 6, :description => "OP CODE method" }
my_case = OpMethodTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "SprintfTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/sprintf_test.rb", :line => 6, :description => "spintf" }
my_case = SprintfTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "StringSplitTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/string_split_test.rb", :line => 6, :description => "String#split" }
my_case = StringSplitTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "ObjectTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/object_test.rb", :line => 6, :description => "Object class" }
my_case = ObjectTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "ArrayTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/array_test.rb", :line => 6, :description => "Array class" }
my_case = ArrayTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "SymbolTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/symbol_test.rb", :line => 6, :description => "Symbol class" }
my_case = SymbolTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

information = { :test_class_name => "HashTest", :method_name => "all", :path => "/home/hasumi/work/mrubyc/test/hash_test.rb", :line => 6, :description => "Hash class" }
my_case = HashTest.new(information)
my_case.setup
my_case.all
my_case.check_mock
my_case.teardown

debugprint("finish test")

exit_code = summerize
exit(exit_code)
